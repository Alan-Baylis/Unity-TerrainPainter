




#pragma kernel Generate_Height_Map 
#pragma kernel Generate_NeighborTerrain_Height_Map 
#pragma kernel Generate_NeighborTerrain_Slope_Map 
#pragma kernel Generate_Slope_Map
#pragma kernel Generate_SnowWeight_Map

#pragma kernel FlowMap_AddWater
#pragma kernel FlowMap_GenerateNeighborTerrainWaterMaps 
#pragma kernel FlowMap_CalculateWaterOut
#pragma kernel FlowMap_MoveWater
#pragma kernel FlowMap_Generate

#pragma kernel CurvatureMap_FirstPass 
#pragma kernel CurvatureMap_SecondPass
#pragma kernel CurvatureMap_Generate

#pragma kernel Generate_SplatMap
#pragma kernel Normalize_SplatMap

#pragma kernel Generate_ColorMap









struct SplatPaintRules
{
	float splatType;
	float paintMethod;

	float useFlowMap;
	float useConvexityMap;
	float useConcavityMap;
	float useAspectMap;
	float useTextureMap;

    float flowMapWeight;
	float flowMapTransition;
	float flowMapScale;
	float flowMapHeightWeight;
	float isInverseFlowMapHeightWeight;
	float flowMapSlopeWeight;
	float isInverseFlowMapSlopeWeight;
	float flowMapEffect;

    float convexityMapWeight;
	float convexityMapTransition;
	float convexityMapScale;
	float convexityMapEffect;

    float concavityMapWeight;
	float concavityMapTransition;
	float concavityMapScale;
	float concavityMapEffect;

	float aspectMapWeight;
	float aspectMapPower;
	float aspectMapDirection;	// 0 - 360  degrees
	float aspectMapEffect;

	float textureMapWeight;
	float textureMapChannel;
	float textureMapResolution;
    float textureMapEffect;



    float heightMinStart;
	float heightMinEnd;
	float heightMaxStart;
	float heightMaxEnd;
	float heightTransitionFrequency;
	float heightTransitionCutoff;

    float slopeMinStart;
	float slopeMinEnd;
	float slopeMaxStart;
	float slopeMaxEnd;
	float slopeTransitionFrequency;
	float slopeTransitionCutoff;

    
	float snowAmount;
	float snowTransitionSize;
	float snowTransitionFrequency;
	float snowTransitionCutoff;
};








float useDrawInstanced ;


float4 terrainSize ;
float4 terrainPosition ;

int heightmapResolution  ;
int alphaMapResolution  ;

int splatCount ;
int splatRuleBufferIndex ;

int flowMapIteration ;

float4 hasNeighborTerrains ;
float4 cornerNeighborTerrainsHeights ; 
float4 cornerNeighborTerrainsSlopes ; 

float uvSize ;





RWStructuredBuffer<SplatPaintRules> splatPaintRulesBuffer ;
RWStructuredBuffer<float> splat_Map_Total_Weight_Buffer ;



RWTexture2D<float> unity_heightMap ;
RWTexture2D<float4> unity_normalMap ;


RWTexture2D<float4> height_slope_snowWeight_water_Maps ;
RWTexture2D<float4> height_slope_snowWeight_water_Maps_left ;
RWTexture2D<float4> height_slope_snowWeight_water_Maps_right ;
RWTexture2D<float4> height_slope_snowWeight_water_Maps_down ;
RWTexture2D<float4> height_slope_snowWeight_water_Maps_up ;


RWTexture2D<float4> neighbor_terrain_heightMaps ;
RWTexture2D<float4> neighbor_terrain_slopeMaps ;


RWTexture2D<float4> convexity_concavitiy_flow_Maps ;
RWTexture2D<float4> convexity_concavitiy_flow_Maps_left ;
RWTexture2D<float4> convexity_concavitiy_flow_Maps_up ;
RWTexture2D<float4> convexity_concavitiy_flow_Maps_right ;
RWTexture2D<float4> convexity_concavitiy_flow_Maps_down ;
RWTexture2D<float4> convexity_concavitiy_flow_Maps_newCurvature ;


RWTexture2D<float4> waterMap_left;
RWTexture2D<float4> waterMap_up;
RWTexture2D<float4> waterMap_right;
RWTexture2D<float4> waterMap_down;
RWTexture2D<float4> neighbor_terrain_waterMaps ;


RWTexture2D<float4> waterOutMap_this;
RWTexture2D<float4> waterOutMap_left;
RWTexture2D<float4> waterOutMap_up;
RWTexture2D<float4> waterOutMap_right;
RWTexture2D<float4> waterOutMap_down;


Texture2D<float4> textureMap ;


RWTexture2D<float4> splatMapsArray ;
RWTexture2D<float4> triplanarWeightMap;


Texture2D<float4> diffuseTexture ;
Texture2D<float4> normalTexture ;
RWTexture2D<float4> colorMapDiffuse ;
RWTexture2D<float4> colorMapNormal ;








// 3D noise
// source : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl


float3 mod289(float3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float4 mod289(float4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float4 permute(float4 x) {
     return mod289(((x*34.0)+1.0)*x);
}

float4 taylorInvSqrt(float4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float snoise(float3 v)
  { 
  const float2  C = float2(1.0/6.0, 1.0/3.0) ;
  const float4  D = float4(0.0, 0.5, 1.0, 2.0);

// First corner
  float3 i  = floor(v + dot(v, C.yyy) );
  float3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  float3 g = 0; // step(x0.yzx, x0.xyz);
    if(length(x0.yzx) > 0)
	g = 0;
	else
	g = 1;

  float3 l = 1.0 - g;
  float3 i1 = min( g.xyz, l.zxy );
  float3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  float3 x1 = x0 - i1 + C.xxx;
  float3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  float3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// Permutations
  i = mod289(i); 
  float4 p = permute( permute( permute( 
             i.z + float4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + float4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + float4(0.0, i1.x, i2.x, 1.0 ));

// Gradients: 7x7 points over a square, mapped onto an octahedron.
// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  float3  ns = n_ * D.wyz - D.xzx;

  float4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  float4 x_ = floor(j * ns.z);
  float4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  float4 x = x_ *ns.x + ns.yyyy;
  float4 y = y_ *ns.x + ns.yyyy;
  float4 h = 1.0 - abs(x) - abs(y);

  float4 b0 = float4( x.xy, y.xy );
  float4 b1 = float4( x.zw, y.zw );

  //float4 s0 = float4(lessThan(b0,0.0))*2.0 - 1.0;
  //float4 s1 = float4(lessThan(b1,0.0))*2.0 - 1.0;
  float4 s0 = floor(b0)*2.0 + 1.0;
  float4 s1 = floor(b1)*2.0 + 1.0;
  float4 sh = 0 ; // -step(h, float4(0.0));
  if(length(h) > 0)
	sh = 0;
	else
	sh = -1;

  float4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  float4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  float3 p0 = float3(a0.xy,h.x);
  float3 p1 = float3(a0.zw,h.y);
  float3 p2 = float3(a1.xy,h.z);
  float3 p3 = float3(a1.zw,h.w);

//Normalise gradients
  float4 norm = taylorInvSqrt(float4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  float4 m = max(0.6 - float4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, float4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
  }













float Noise(uint3 id, float p_frequency)
{

	float _pos_x =   terrainPosition.x + (  terrainSize.x * (  (float)id.x/ ( (float)heightmapResolution - 1) )  ) ;
	float _pos_z =   terrainPosition.z + (  terrainSize.z * (  (float)id.y/ ( (float)heightmapResolution - 1) )  ) ;
	float _pos_y =	 terrainPosition.y + (  terrainSize.y * height_slope_snowWeight_water_Maps[id.xy].x  ) ;

	float3 _vector = float3(_pos_x, _pos_y, _pos_z) ;

	return saturate(snoise(_vector * 0.005 * p_frequency));
}






float AdjacentHeight(uint3 id, int p_left_right, int p_up_down)
{
	float _returnHeight = 0;

	int _index_X = 0 ;
	int _index_Y = 0 ;

	_index_X = clamp(id.x + p_left_right,   0, heightmapResolution -1) ;
	_index_Y = clamp(id.y + p_up_down,   0, heightmapResolution -1) ;
	_returnHeight = height_slope_snowWeight_water_Maps[uint2(_index_X , _index_Y)].x ; 



	if(id.x == 0  &&  p_left_right == -1)
		_returnHeight = neighbor_terrain_heightMaps[uint2(heightmapResolution -2 , id.y)].x ;	
	
	if(id.y == heightmapResolution -1  &&  p_up_down == 1)
		_returnHeight = neighbor_terrain_heightMaps[uint2(id.x, 1)].y ;	

	if(id.x == heightmapResolution -1  &&  p_left_right == 1)
		_returnHeight = neighbor_terrain_heightMaps[uint2(1 , id.y)].z ;	

	if(id.y == 0  &&  p_up_down == -1)
		_returnHeight = neighbor_terrain_heightMaps[uint2(id.x, heightmapResolution -2)].w ;	


	
	if(id.x == 0  &&  id.y == 0  &&  p_left_right == -1  && p_up_down == -1)
		_returnHeight = cornerNeighborTerrainsHeights.w ;	

	if(id.x == 0  &&  id.y == heightmapResolution -1  &&  p_left_right == -1  && p_up_down == 1)
		_returnHeight = cornerNeighborTerrainsHeights.x ;	

	if(id.x == heightmapResolution -1 && id.y == heightmapResolution -1  &&  p_left_right == 1  && p_up_down == 1)
		_returnHeight = cornerNeighborTerrainsHeights.y ;	

	if(id.x == heightmapResolution -1  &&  id.y == 0  &&  p_left_right == 1  && p_up_down == -1)
		_returnHeight = cornerNeighborTerrainsHeights.z ;	
	


	return _returnHeight;
}





float AdjacentSlope(uint3 id, int p_left_right, int p_up_down)
{
	float _returnSlope = 0;

	int _index_X = 0 ;
	int _index_Y = 0 ;

	_index_X = clamp(id.x + p_left_right,   0, heightmapResolution -1) ;
	_index_Y = clamp(id.y + p_up_down,   0, heightmapResolution -1) ;
	_returnSlope = height_slope_snowWeight_water_Maps[uint2(_index_X , _index_Y)].y ; 



	if(id.x == 0  &&  p_left_right == -1)
		_returnSlope = neighbor_terrain_slopeMaps[uint2(heightmapResolution -2 , id.y)].x ;	
	
	if(id.y == heightmapResolution -1  &&  p_up_down == 1)
		_returnSlope = neighbor_terrain_slopeMaps[uint2(id.x, 1)].y ;	

	if(id.x == heightmapResolution -1  &&  p_left_right == 1)
		_returnSlope = neighbor_terrain_slopeMaps[uint2(1 , id.y)].z ;	

	if(id.y == 0  &&  p_up_down == -1)
		_returnSlope = neighbor_terrain_slopeMaps[uint2(id.x, heightmapResolution -2)].w ;	


	
	if(id.x == 0  &&  id.y == 0  &&  p_left_right == -1  && p_up_down == -1)
		_returnSlope = cornerNeighborTerrainsSlopes.w ;	

	if(id.x == 0  &&  id.y == heightmapResolution -1  &&  p_left_right == -1  && p_up_down == 1)
		_returnSlope = cornerNeighborTerrainsSlopes.x ;	

	if(id.x == heightmapResolution -1 && id.y == heightmapResolution -1  &&  p_left_right == 1  && p_up_down == 1)
		_returnSlope = cornerNeighborTerrainsSlopes.y ;	

	if(id.x == heightmapResolution -1  &&  id.y == 0  &&  p_left_right == 1  && p_up_down == -1)
		_returnSlope = cornerNeighborTerrainsSlopes.z ;	
	



	return _returnSlope ;
}




float3 CalculateNormal(uint3 id)
{
	float3 _normal = float3(0,0,0);
	
	if(useDrawInstanced > 0.0)
	{
		float4 _packedNormal = unity_normalMap[id.xy] ;
		_normal = _packedNormal * 2.0 - 1.0 ;
		_normal = normalize(float3(_normal.x, _normal.y * 0.5, _normal.z)) ;
	}
	else
	{
		float _left_to_right_height_difference	= AdjacentHeight(id, -1, 0)  -  AdjacentHeight(id, 1, 0) ;
		float _down_to_up_height_difference		= AdjacentHeight(id, 0, -1)  -  AdjacentHeight(id, 0 , 1) ; 

		_normal = float3( _left_to_right_height_difference * terrainSize.x ,    4.0 * ((terrainSize.x / terrainSize.y)  +  (terrainSize.z / terrainSize.y)),   _down_to_up_height_difference * terrainSize.z) ;
		_normal = normalize(_normal) ;
		unity_normalMap[id.xy] = float4(normalize(float3(_normal.x, _normal.y * 2.0, _normal.z)), unity_normalMap[id.xy].w) * 0.5 + 0.5 ;
	}

	return _normal ;
}






float CalculateSlope(uint3 id)
{
	float _slope = 0;

	float3 _normal = float3(0,0,0);

	_normal = CalculateNormal(id);

	_slope = 1 - dot(float3(0.0 , 1.0 , 0.0), _normal) ;

	return saturate(_slope) ;
}










float CalculateSnowWeight(uint3 id)
{
	float _snowWeight = 0;

	_snowWeight = (height_slope_snowWeight_water_Maps[id.xy].x * (1 - height_slope_snowWeight_water_Maps[id.xy].y)) ;
	//	_snowWeight = 2*_snowWeight -1 ;

	return saturate(_snowWeight) ;
}







float3 GetNormal(uint3 id)
{
	float3 _normal = float3(0,0,0);
	
	float4 _packedNormal = unity_normalMap[id.xy] ;
	_normal = _packedNormal * 2.0 - 1.0 ;
	_normal = normalize(float3(_normal.x, _normal.y * 0.5, _normal.z)) ;
	
	return _normal ;
}









float GetWaterMapValue(uint3 id, int p_left_right, int p_up_down)
{
	float _returnWater = 0;

	int _index_X = 0 ;
	int _index_Y = 0 ;

	_index_X = clamp(id.x + p_left_right,  0, heightmapResolution -1) ;
	_index_Y = clamp(id.y + p_up_down,   0, heightmapResolution -1) ;
	_returnWater = height_slope_snowWeight_water_Maps[uint2(_index_X , _index_Y)].w ; 


	if(id.x == 0  &&  p_left_right == -1)
		_returnWater = neighbor_terrain_waterMaps[uint2(heightmapResolution -2 , id.y)].x ;	

	if(id.y == heightmapResolution -1  &&  p_up_down == 1)
		_returnWater = neighbor_terrain_waterMaps[uint2(id.x, 1)].y ;	

	if(id.x == heightmapResolution -1  &&  p_left_right == 1)
		_returnWater = neighbor_terrain_waterMaps[uint2(1 , id.y)].z ;	

	if(id.y == 0  &&  p_up_down == -1)
		_returnWater = neighbor_terrain_waterMaps[uint2(id.x, heightmapResolution -2)].w ;	


	return _returnWater ;
}










float4 GetWaterOut_MapValue(uint3 id, int p_left_right, int p_up_down)
{
	float4 _returnWaterOut = float4(0,0,0,0);

	int _index_X = 0 ;
	int _index_Y = 0 ;

	_index_X = clamp(id.x + p_left_right,   0, heightmapResolution -1) ;
	_index_Y = clamp(id.y + p_up_down,   0, heightmapResolution -1) ;
	_returnWaterOut = waterOutMap_this[uint2(_index_X , _index_Y)] ; 
	


	if(id.x == 0  &&  p_left_right == -1)
		_returnWaterOut = waterOutMap_left[uint2(heightmapResolution -2 , id.y)] ;	

	if(id.y == heightmapResolution -1  &&  p_up_down == 1)
		_returnWaterOut = waterOutMap_up[uint2(id.x, 1)] ;	

	if(id.x == heightmapResolution -1  &&  p_left_right == 1)
		_returnWaterOut = waterOutMap_right[uint2(1 , id.y)] ;	

	if(id.y == 0  &&  p_up_down == -1)
		_returnWaterOut = waterOutMap_down[uint2(id.x, heightmapResolution -2)] ;	



	return _returnWaterOut ;
}





float4 GetWaterSpeed_Value(uint3 id, int p_left_right, int p_up_down)
{
	float4 _returnWaterSpeed = float4(0,0,0,0);

	int _index_X = 0 ;
	int _index_Y = 0 ;

	_index_X = clamp(id.x + p_left_right,   0, heightmapResolution -1) ;
	_index_Y = clamp(id.y + p_up_down,   0, heightmapResolution -1) ;
	_returnWaterSpeed = convexity_concavitiy_flow_Maps[uint2(_index_X , _index_Y)] ; 

	return _returnWaterSpeed ;
}






float2 GetCurvatureValue(uint3 id, int p_left_right, int p_up_down)
{
	float4 _returnCurvature = 0;

	int _index_X = 0 ;
	int _index_Y = 0 ;

	_index_X = clamp(id.x + p_left_right,  0, heightmapResolution -1) ;
	_index_Y = clamp(id.y + p_up_down,   0, heightmapResolution -1) ;
	_returnCurvature = convexity_concavitiy_flow_Maps[uint2(_index_X , _index_Y)] ; 


	if(id.x == 0  &&  p_left_right == -1)
		_returnCurvature = convexity_concavitiy_flow_Maps_left[uint2(heightmapResolution -2 , id.y)] ;	

	if(id.y == heightmapResolution -1  &&  p_up_down == 1)
		_returnCurvature = convexity_concavitiy_flow_Maps_up[uint2(id.x, 1)] ;	

	if(id.x == heightmapResolution -1  &&  p_left_right == 1)
		_returnCurvature = convexity_concavitiy_flow_Maps_right[uint2(1 , id.y)] ;	

	if(id.y == 0  &&  p_up_down == -1)
		_returnCurvature = convexity_concavitiy_flow_Maps_down[uint2(id.x, heightmapResolution -2)] ;	


	return _returnCurvature.xy ;
}

























float CalcualteWeight(uint3 id, int p_left_right, int p_up_down, int p_splatRuleBufferIndex, float p_totalWeight, float p_normalized_x = 1.0, float p_normalized_y = 1.0)
{

	float _weight = 0.0 ;
	float _map_mask_weight_include = 1.0 ;
	float _map_mask_weight_additive = 0.0 ;


	float _splatType = splatPaintRulesBuffer[splatRuleBufferIndex].splatType ;
	float _paintMethod = splatPaintRulesBuffer[splatRuleBufferIndex].paintMethod ;



	// flow, convexity, concavity, aspect, texture  mask maps

	if(splatPaintRulesBuffer[p_splatRuleBufferIndex].useFlowMap > 0 && _splatType != 1)
	{
		float _flowmap_effect = splatPaintRulesBuffer[p_splatRuleBufferIndex].flowMapEffect ;
		float _flowmap_min_transition = splatPaintRulesBuffer[p_splatRuleBufferIndex].flowMapTransition ;
		float _flowmap_weight_min_end = saturate(splatPaintRulesBuffer[p_splatRuleBufferIndex].flowMapWeight - _flowmap_min_transition);
		float _flowmap_weight_min_start = splatPaintRulesBuffer[p_splatRuleBufferIndex].flowMapWeight ;

		float _flowmap_scale = splatPaintRulesBuffer[p_splatRuleBufferIndex].flowMapScale ;
		float _flowmap_value =  convexity_concavitiy_flow_Maps[id.xy].z ;
		float _flowmap_height_weight = splatPaintRulesBuffer[p_splatRuleBufferIndex].flowMapHeightWeight ;
		float _flowmap_height = AdjacentHeight(id, 0, 0);
		float _flowmap_slope_weight = splatPaintRulesBuffer[p_splatRuleBufferIndex].flowMapSlopeWeight ;
		float _flowmap_slope = AdjacentSlope(id, 0, 0);
		

		_flowmap_value *= _flowmap_scale ;

		_flowmap_value = saturate(_flowmap_value) ;



		if(splatPaintRulesBuffer[p_splatRuleBufferIndex].isInverseFlowMapHeightWeight > 0)
			_flowmap_height = 1.0 - _flowmap_height ;


		if(splatPaintRulesBuffer[p_splatRuleBufferIndex].isInverseFlowMapSlopeWeight > 0)
			_flowmap_slope = 1.0 - _flowmap_slope ;
			



		_flowmap_value = (_flowmap_value * _flowmap_height_weight * _flowmap_height) + (_flowmap_value * (1.0 - _flowmap_height_weight)) ;
		_flowmap_value = (_flowmap_value * _flowmap_slope_weight * _flowmap_slope) + (_flowmap_value * (1.0 - _flowmap_slope_weight)) ;
		
		
		_flowmap_weight_min_start = 1 - sqrt(_flowmap_weight_min_start) ;
		_flowmap_weight_min_end = 1 - sqrt(_flowmap_weight_min_end) ;

		

		float _flowmap_transition_size = _flowmap_weight_min_end - _flowmap_weight_min_start ;
		

		float _mask_value = 0.0 ;

		if(_flowmap_value >= _flowmap_weight_min_start)
		{
			if(_flowmap_value >= _flowmap_weight_min_end)
			{
				_mask_value = 1.0 ;
			}
			else
			{
				_mask_value = ((_flowmap_value - _flowmap_weight_min_start) / (_flowmap_transition_size + 0.00001)) ;
			}
		}




		if(_flowmap_effect == 0)
		{
			_map_mask_weight_include *= _mask_value ;
		}
		else if(_flowmap_effect == 1)
		{
			_map_mask_weight_include *= saturate(1.0 - _mask_value) ;
		}
		else if(_flowmap_effect == 2)
		{
			_map_mask_weight_additive += _mask_value ;
		}

		
	}





	if(splatPaintRulesBuffer[p_splatRuleBufferIndex].useConvexityMap > 0 && _splatType != 1)
	{
		float _convexitymap_effect = splatPaintRulesBuffer[p_splatRuleBufferIndex].convexityMapEffect ;
		float _convexitymap_min_transition = splatPaintRulesBuffer[p_splatRuleBufferIndex].convexityMapTransition ;
		float _convexitymap_weight_min_end = saturate(splatPaintRulesBuffer[p_splatRuleBufferIndex].convexityMapWeight - _convexitymap_min_transition);
		float _convexitymap_weight_min_start = splatPaintRulesBuffer[p_splatRuleBufferIndex].convexityMapWeight ;

		float _convexitymap_scale = splatPaintRulesBuffer[p_splatRuleBufferIndex].convexityMapScale ;
		float _convexitymap_value =  convexity_concavitiy_flow_Maps[id.xy].x ;

		_convexitymap_value *= _convexitymap_scale ;


		_convexitymap_weight_min_start = 1 - (_convexitymap_weight_min_start) ;
		_convexitymap_weight_min_end = 1 - (_convexitymap_weight_min_end) ;




		float _convexitymap_size = _convexitymap_weight_min_end - _convexitymap_weight_min_start ;
		
		float _mask_value = 0.0 ;
		
		if(_convexitymap_value >= _convexitymap_weight_min_start)
		{
			if(_convexitymap_value >= _convexitymap_weight_min_end)
			{
				_mask_value = 1.0 ;
			}
			else
			{
				_mask_value = ((_convexitymap_value - _convexitymap_weight_min_start) / (_convexitymap_size + 0.00001)) ;
			}
		}



		if(_convexitymap_effect == 0)
		{
			_map_mask_weight_include *= _mask_value ;
		}
		else if(_convexitymap_effect == 1)
		{
			_map_mask_weight_include *= saturate(1.0 - _mask_value) ;
		}
		else if(_convexitymap_effect == 2)
		{
			_map_mask_weight_additive += _mask_value ;
		}
	}



	if(splatPaintRulesBuffer[p_splatRuleBufferIndex].useConcavityMap > 0 && _splatType != 1)
	{
		float _concavitymap_effect = splatPaintRulesBuffer[p_splatRuleBufferIndex].concavityMapEffect ;
		float _concavitymap_min_transition = splatPaintRulesBuffer[p_splatRuleBufferIndex].concavityMapTransition ;
		float _concavitymap_weight_min_end = saturate(splatPaintRulesBuffer[p_splatRuleBufferIndex].concavityMapWeight - _concavitymap_min_transition);
		float _concavitymap_weight_min_start = splatPaintRulesBuffer[p_splatRuleBufferIndex].concavityMapWeight ;

		float _concavitymap_scale = splatPaintRulesBuffer[p_splatRuleBufferIndex].concavityMapScale ;
		float _concavitymap_value = convexity_concavitiy_flow_Maps[id.xy].y ;

		_concavitymap_value *= _concavitymap_scale ;


		_concavitymap_weight_min_start = 1 - (_concavitymap_weight_min_start) ;
		_concavitymap_weight_min_end = 1 - (_concavitymap_weight_min_end) ;




		float _concavitymap_size = _concavitymap_weight_min_end - _concavitymap_weight_min_start ;
		
		float _mask_value = 0.0 ;

		if(_concavitymap_value >= _concavitymap_weight_min_start)
		{
			if(_concavitymap_value >= _concavitymap_weight_min_end)
			{
				_mask_value = 1.0 ;
			}
			else
			{
				_mask_value = ((_concavitymap_value - _concavitymap_weight_min_start) / (_concavitymap_size + 0.00001)) ;
			}
		}


		
		if(_concavitymap_effect == 0)
		{
			_map_mask_weight_include *= _mask_value ;
		}
		else if(_concavitymap_effect == 1)
		{
			_map_mask_weight_include *= saturate(1.0 - _mask_value) ;
		}
		else if(_concavitymap_effect == 2)
		{
			_map_mask_weight_additive += _mask_value ;
		}

	}



	if(splatPaintRulesBuffer[p_splatRuleBufferIndex].useAspectMap > 0 && _splatType != 1)
	{
		float _aspectmap_effect = splatPaintRulesBuffer[p_splatRuleBufferIndex].aspectMapEffect ;
		float _aspectmap_weight = splatPaintRulesBuffer[p_splatRuleBufferIndex].aspectMapWeight ;
		float _aspectmap_power = splatPaintRulesBuffer[p_splatRuleBufferIndex].aspectMapPower ;

		float _aspectmap_direction_angle = splatPaintRulesBuffer[p_splatRuleBufferIndex].aspectMapDirection ;
		float3 _aspectmap_direction_vector = normalize(float3( sin(radians(_aspectmap_direction_angle)) , 0.0 , cos(radians(_aspectmap_direction_angle)) )) ;

		float3 _normal = GetNormal(id);

		float _mask_value = 0.0 ;

		

		
		if(_aspectmap_effect == 0)
		{
			_mask_value = dot(_normal, _aspectmap_direction_vector) * _aspectmap_power * _aspectmap_weight   +   (1.0 - _aspectmap_weight);
			_map_mask_weight_include *= _mask_value ;
		}
		else if(_aspectmap_effect == 1)
		{
			_mask_value = dot(_normal, _aspectmap_direction_vector) * _aspectmap_power * _aspectmap_weight ;
			_map_mask_weight_include *= saturate(1.0 - _mask_value) ;
		}
		else if(_aspectmap_effect == 2)
		{
			_mask_value = dot(_normal, _aspectmap_direction_vector) * _aspectmap_power * _aspectmap_weight ;
			_map_mask_weight_additive += _mask_value ;
		}

	}



	if(splatPaintRulesBuffer[p_splatRuleBufferIndex].useTextureMap > 0 && _splatType != 1)
	{
		float _texturemap_effect = splatPaintRulesBuffer[p_splatRuleBufferIndex].textureMapEffect ;
		float _texturemap_weight = splatPaintRulesBuffer[p_splatRuleBufferIndex].textureMapWeight ;

		float _texturemap_resolution = splatPaintRulesBuffer[p_splatRuleBufferIndex].textureMapResolution ;

		float _tr = (float)(_texturemap_resolution - 1);

		uint _rounded_x = (uint)round(p_normalized_x * _tr) ;
		uint _rounded_y = (uint)round(p_normalized_y * _tr) ;
		
		uint2 _xy = uint2(_rounded_x, _rounded_y) ;

		float4 _texturemap_rgba = textureMap[_xy];

		float _texturemap_value = 0.0 ;
		float _texturemap_channel = splatPaintRulesBuffer[p_splatRuleBufferIndex].textureMapChannel ;



		if(_texturemap_channel == 0)
			_texturemap_value = _texturemap_rgba.r ;
		else if(_texturemap_channel == 1)
			_texturemap_value = _texturemap_rgba.g ;
		else if(_texturemap_channel == 2)
			_texturemap_value = _texturemap_rgba.b ;
		else if(_texturemap_channel == 3)
			_texturemap_value = _texturemap_rgba.a ;

		

		float _mask_value = 0.0 ;


		if(_texturemap_effect == 0)
		{
			_mask_value = _texturemap_value * _texturemap_weight   +   (1.0 - _texturemap_weight);
			_map_mask_weight_include *= _mask_value ;
		}
		else if(_texturemap_effect == 1)
		{
			_mask_value = _texturemap_value * _texturemap_weight ;
			_map_mask_weight_include *= saturate(1.0 - _mask_value) ;
		}
		else if(_texturemap_effect == 2)
		{
			_mask_value = _texturemap_value * _texturemap_weight ;
			_map_mask_weight_additive += _mask_value ;
		}

	}

















	
	if(_splatType == 0)
	{

		float _height_Weight = 0.0;
		float _slope_Weight = 0.0;



		float _height = AdjacentHeight(id , p_left_right , p_up_down) * terrainSize.y ;
		float _slope = AdjacentSlope(id , p_left_right , p_up_down) * 90.0 ;
	


		float _height_transition_noise = Noise(id, splatPaintRulesBuffer[p_splatRuleBufferIndex].heightTransitionFrequency);
		float _slope_transition_noise = Noise(id, splatPaintRulesBuffer[p_splatRuleBufferIndex].slopeTransitionFrequency);





		float _height_min_start = splatPaintRulesBuffer[p_splatRuleBufferIndex].heightMinStart ;
		float _height_min_end = splatPaintRulesBuffer[p_splatRuleBufferIndex].heightMinEnd ;
		float _height_max_start = splatPaintRulesBuffer[p_splatRuleBufferIndex].heightMaxStart ;
		float _height_max_end = splatPaintRulesBuffer[p_splatRuleBufferIndex].heightMaxEnd ;

		float _slope_min_start = splatPaintRulesBuffer[p_splatRuleBufferIndex].slopeMinStart ;
		float _slope_min_end = splatPaintRulesBuffer[p_splatRuleBufferIndex].slopeMinEnd ;
		float _slope_max_start = splatPaintRulesBuffer[p_splatRuleBufferIndex].slopeMaxStart ;
		float _slope_max_end = splatPaintRulesBuffer[p_splatRuleBufferIndex].slopeMaxEnd ;





		float _height_min_transition_size = _height_min_end - _height_min_start ;
		float _height_max_transition_size = _height_max_end - _height_max_start ;

		float _slope_min_transition_size = _slope_min_end - _slope_min_start ;
		float _slope_max_transition_size = _slope_max_end - _slope_max_start ;





		float _height_difference_from_height_min_start = _height - _height_min_start ;
		float _height_difference_from_height_max_end = _height_max_end - _height ;

		float _slope_difference_from_slope_min_start = _slope - _slope_min_start ;
		float _slope_difference_from_slope_max_end = _slope_max_end - _slope ;



		float _height_transition_cutoff = splatPaintRulesBuffer[p_splatRuleBufferIndex].heightTransitionCutoff ;
		float _slope_transition_cutoff = splatPaintRulesBuffer[p_splatRuleBufferIndex].slopeTransitionCutoff ;

		float _height_difference_ratio_min = (_height_difference_from_height_min_start / _height_min_transition_size);
		float _height_difference_ratio_max = (_height_difference_from_height_max_end / _height_max_transition_size) ;

		float _slope_difference_ratio_min = (_slope_difference_from_slope_min_start / _slope_min_transition_size);
		float _slope_difference_ratio_max = (_slope_difference_from_slope_max_end / _slope_max_transition_size) ;







		if(_height >= _height_min_start  &&  _height <= _height_max_end)
		{
			if(_height >= _height_min_end  &&   _height <= _height_max_start)
			{
				_height_Weight = 1.0 ;
			}
			else
			{
				if(_height < _height_min_end)
				{
					_height_Weight = saturate((_height_transition_noise + _height_difference_ratio_min) * _height_difference_ratio_min) ;

					if(_height_Weight < _height_transition_cutoff)
					{
						_height_Weight = 0.0 ;
					}
				}
				else 
				{
					_height_Weight = saturate((_height_transition_noise + _height_difference_ratio_max) * _height_difference_ratio_max) ;

					if(_height_Weight < _height_transition_cutoff)
					{
						_height_Weight = 0.0 ;
					}
				}
			}
		}



		if(_slope >= _slope_min_start  &&  _slope <= _slope_max_end)
		{
			if(_slope >= _slope_min_end  && _slope <= _slope_max_start)
			{
				_slope_Weight = 1.0 ;
			}
			else
			{
				if(_slope < _slope_min_end)
				{
					_slope_Weight = saturate((_slope_transition_noise + _slope_difference_ratio_min) * _slope_difference_ratio_min) ;

					if(_slope_Weight < _slope_transition_cutoff)
					{
						_slope_Weight = 0.0 ;
					}
				}
				else 
				{
					_slope_Weight = saturate((_slope_transition_noise + _slope_difference_ratio_max) * _slope_difference_ratio_max) ;

					if(_slope_Weight < _slope_transition_cutoff)
					{
						_slope_Weight = 0.0 ;
					}
				}
			}
		}

		_weight = saturate(_height_Weight * _slope_Weight)  ;

	}

	else if(_splatType == 1)
	{
		if(_paintMethod == 0)
		{
			_weight = saturate(1 - p_totalWeight) ;
		}
		else if(_paintMethod == 1)
		{
			_weight = 1.0 ;
		}
	}

	else if(_splatType == 2)
	{

		float _snow_map_value = height_slope_snowWeight_water_Maps[id.xy].z ;
		float _snow_amount =  splatPaintRulesBuffer[p_splatRuleBufferIndex].snowAmount ;
		
		_snow_amount = 1.0 - sqrt(_snow_amount) ;

		float _snow_transition_size = splatPaintRulesBuffer[p_splatRuleBufferIndex].snowTransitionSize ;
		float _snow_transition_noise = Noise(id, splatPaintRulesBuffer[p_splatRuleBufferIndex].snowTransitionFrequency) ;
		float _snow_transition_cutoff = splatPaintRulesBuffer[p_splatRuleBufferIndex].snowTransitionCutoff ;

		float _snow_min_start = _snow_amount ;
		float _snow_min_end = _snow_min_start + _snow_transition_size ;

		float _snow_difference_from_slope_min_start =  _snow_map_value  - _snow_amount ;
		float _snow_difference_ratio_min = _snow_difference_from_slope_min_start / _snow_transition_size ;


		if(_snow_map_value > _snow_min_start)
		{
			if(_snow_map_value < _snow_min_end)
			{
				_weight =  saturate((_snow_transition_noise + _snow_difference_ratio_min) * _snow_difference_ratio_min) ;

				if(_weight < _snow_transition_cutoff)
				{
					_weight = 0.0 ;
				}
			}
			else	
			{
				_weight = 1 ;
			}
		}
	}
	





	_weight *= _map_mask_weight_include ;
	_weight = saturate(_weight + _map_mask_weight_additive) ;

	
	if(_paintMethod == 0 && _splatType != 1)
	{
		_weight = saturate(_weight * (1 - p_totalWeight)) ;
	}



	return _weight ;
}
























////////////////////   kernels    ////////////////////



[numthreads(8,8,1)]
void Generate_Height_Map (uint3 id : SV_DispatchThreadID)
{
	// Multiplied with 2.0 Because Unity's Terrain.TerrainData.heightmap returns halved values of heights ;
	float _height = 2.0 * (unity_heightMap[id.xy])  ;	
	height_slope_snowWeight_water_Maps[id.xy] = float4( _height,    height_slope_snowWeight_water_Maps[id.xy].yzw ) ;
}


[numthreads(8,8,1)]
void Generate_NeighborTerrain_Height_Map (uint3 id : SV_DispatchThreadID)
{
	neighbor_terrain_heightMaps[id.xy] = float4(  height_slope_snowWeight_water_Maps_left[id.xy].x , height_slope_snowWeight_water_Maps_up[id.xy].x , height_slope_snowWeight_water_Maps_right[id.xy].x , height_slope_snowWeight_water_Maps_down[id.xy].x );
}


[numthreads(8,8,1)]
void Generate_Slope_Map (uint3 id : SV_DispatchThreadID)
{
	float _slope = CalculateSlope(id) ;
	height_slope_snowWeight_water_Maps[id.xy] = float4( height_slope_snowWeight_water_Maps[id.xy].x,  _slope, height_slope_snowWeight_water_Maps[id.xy].zw) ;

	float3 blendWeights = pow(abs(CalculateNormal(id)), 4.0);
	blendWeights = blendWeights / (blendWeights.x + blendWeights.y + blendWeights.z + 0.001);

	triplanarWeightMap[id.xy] = float4(blendWeights, _slope);
}


[numthreads(8,8,1)]
void Generate_NeighborTerrain_Slope_Map (uint3 id : SV_DispatchThreadID)
{
	neighbor_terrain_slopeMaps[id.xy] = float4(  height_slope_snowWeight_water_Maps_left[id.xy].y , height_slope_snowWeight_water_Maps_up[id.xy].y , height_slope_snowWeight_water_Maps_right[id.xy].y , height_slope_snowWeight_water_Maps_down[id.xy].y );
}


[numthreads(8,8,1)]
void Generate_SnowWeight_Map (uint3 id : SV_DispatchThreadID)
{
	float _snowWeight = CalculateSnowWeight(id) ;
	height_slope_snowWeight_water_Maps[id.xy] = float4( height_slope_snowWeight_water_Maps[id.xy].xy,  _snowWeight,     height_slope_snowWeight_water_Maps[id.xy].w) ;
}











// source : https://github.com/Scrawk/Terrain-Topology-Algorithms 


[numthreads(8,8,1)]
void FlowMap_AddWater (uint3 id : SV_DispatchThreadID)
{
//	height_slope_snowWeight_water_Maps[id.xy] = float4(height_slope_snowWeight_water_Maps[id.xy].xyz,  ((1.0 / (terrainSize.y * (float)flowMapIteration)))) ;
	height_slope_snowWeight_water_Maps[id.xy] = float4(height_slope_snowWeight_water_Maps[id.xy].xyz,  0.0001) ;
}



[numthreads(8,8,1)]
void FlowMap_GenerateNeighborTerrainWaterMaps (uint3 id : SV_DispatchThreadID)
{
	neighbor_terrain_waterMaps[id.xy] = float4( waterMap_left[id.xy].w  ,  waterMap_up[id.xy].w  ,  waterMap_right[id.xy].w  ,   waterMap_down[id.xy].w  ) ;
}



[numthreads(8,8,1)]
void FlowMap_CalculateWaterOut (uint3 id : SV_DispatchThreadID)
{
	float _water_Height	 =  GetWaterMapValue(id, 0, 0) ;

	if(_water_Height > 0)
	{
		float _water_Height_left	= GetWaterMapValue(id, -1,  0) ;
		float _water_Height_right	= GetWaterMapValue(id,  1,  0) ;
		float _water_Height_down	= GetWaterMapValue(id,  0, -1) ;
		float _water_Height_up		= GetWaterMapValue(id,  0,  1) ;
		

		float _terrain_Height			= AdjacentHeight(id,   0	,   0);
		float _terrain_Height_left		= AdjacentHeight(id,  -1	,   0);
		float _terrain_Height_right		= AdjacentHeight(id,   1	,   0);
		float _terrain_Height_down		= AdjacentHeight(id,   0	,  -1);
		float _terrain_Height_up		= AdjacentHeight(id,   0	,   1);



		float _difference_left	= (_water_Height + _terrain_Height)  -  (_water_Height_left + _terrain_Height_left) ;
		float _difference_right	= (_water_Height + _terrain_Height)  -  (_water_Height_right + _terrain_Height_right) ;
		float _difference_down	= (_water_Height + _terrain_Height)  -  (_water_Height_down + _terrain_Height_down) ;
		float _difference_up	= (_water_Height + _terrain_Height)  -  (_water_Height_up + _terrain_Height_up) ;



		float _flow_left		= max(0, GetWaterOut_MapValue(id, -1,  0).x + _difference_left) ;
		float _flow_right		= max(0, GetWaterOut_MapValue(id,  1,  0).z + _difference_right) ;
		float _flow_down		= max(0, GetWaterOut_MapValue(id,  0, -1).w + _difference_down) ;
		float _flow_up			= max(0, GetWaterOut_MapValue(id,  0,  1).y + _difference_up) ;


		float _total_Flow = (_flow_left + _flow_right + _flow_down + _flow_up) * 0.2 ;

		if(_total_Flow > 0)
		{
			float _flow_rate = saturate(_water_Height / _total_Flow)  ;

			_flow_left	*= _flow_rate ;
			_flow_right *= _flow_rate ;
			_flow_down	*= _flow_rate ;
			_flow_up	*= _flow_rate ;
		}
		else
		{
			_flow_left	= 0 ;
			_flow_right = 0 ;
			_flow_down	= 0 ;
			_flow_up	= 0 ;
		}

		waterOutMap_this[id.xy] = float4(_flow_left , _flow_up , _flow_right , _flow_down) ;
	}
	
	else
	{
		waterOutMap_this[id.xy] = float4(0,0,0,0) ;
	}

}




[numthreads(8,8,1)]
void FlowMap_MoveWater (uint3 id : SV_DispatchThreadID)
{

	float _waterIn = GetWaterOut_MapValue(id, -1, 0).z + GetWaterOut_MapValue(id, 1, 0).x + GetWaterOut_MapValue(id, 0, -1).y + GetWaterOut_MapValue(id, 0 ,1).w ;

	float _waterOut = GetWaterOut_MapValue(id, 0, 0).x + GetWaterOut_MapValue(id, 0, 0).y + GetWaterOut_MapValue(id, 0, 0).z + GetWaterOut_MapValue(id, 0, 0).w ;

	float _finalWaterAmount = GetWaterMapValue(id, 0, 0) + (_waterIn - _waterOut) * 0.2 ;

	if(_finalWaterAmount < 0) {_finalWaterAmount = 0;}

	height_slope_snowWeight_water_Maps[id.xy] =  float4(height_slope_snowWeight_water_Maps[id.xy].xyz,  _finalWaterAmount) ;

}





[numthreads(8,8,1)]
void FlowMap_Generate (uint3 id : SV_DispatchThreadID)
{

	float _flow_left = 0;
	float _flow_right = 0;
	float _flow_down = 0;
	float _flow_up = 0;



	_flow_left = GetWaterOut_MapValue(id, -1, 0).z - GetWaterOut_MapValue(id, 0, 0).x ;
	_flow_right = GetWaterOut_MapValue(id, 0, 0).z - GetWaterOut_MapValue(id, 1, 0).x ;
	_flow_down = GetWaterOut_MapValue(id, 0, 0).w - GetWaterOut_MapValue(id, 0 ,-1).y ;
	_flow_up = GetWaterOut_MapValue(id, 0 ,1).w - GetWaterOut_MapValue(id, 0, 0).y ;



	float _speed_X = (_flow_left + _flow_right) * 0.5 ;
	float _speed_Y = (_flow_down + _flow_up) * 0.5 ;

	float _water_speed = sqrt(_speed_X *_speed_X  +  _speed_Y * _speed_Y) ;

	convexity_concavitiy_flow_Maps[id.xy] = float4(convexity_concavitiy_flow_Maps[id.xy].xy,    _water_speed,    convexity_concavitiy_flow_Maps[id.xy].w) ;

}







[numthreads(8,8,1)]
void CurvatureMap_FirstPass (uint3 id : SV_DispatchThreadID)
{
	float _convexity = 0.0 ;
	float _concavity = 0.0 ;


	float _this_height		= AdjacentHeight(id,   0	,  0);

	float _left_height		= AdjacentHeight(id,  -1	,  0);
	float _right_height		= AdjacentHeight(id,   1	,  0);
	float _down_height		= AdjacentHeight(id,   0	, -1);
	float _up_height		= AdjacentHeight(id,   0	,  1);

	float _left_up_height		= AdjacentHeight(id,  -1	,  1);
	float _right_up_height		= AdjacentHeight(id,   1	,  1);
	float _left_down_height		= AdjacentHeight(id,  -1	, -1);
	float _right_down_height	= AdjacentHeight(id,   1	, -1);

	float _average_height	= ( _left_height + _right_height + _down_height + _up_height   +  _left_up_height + _right_up_height + _left_down_height + _right_down_height) / 8.0 ;
//	float _average_height	= ( _left_height + _right_height + _down_height + _up_height ) / 4.0;


	float _height_difference_from_average = _this_height - _average_height ;

	_convexity = saturate(_height_difference_from_average) ;
	_concavity = saturate( -1 * _height_difference_from_average) ; 

	convexity_concavitiy_flow_Maps[id.xy] = float4( _convexity,  _concavity,  convexity_concavitiy_flow_Maps[id.xy].zw) ;
}


[numthreads(8,8,1)]
void CurvatureMap_SecondPass (uint3 id : SV_DispatchThreadID)
{

	float2 _this 	= GetCurvatureValue(id,  0,  0) ; 
	float2 _left 	= GetCurvatureValue(id, -1,  0) ;
	float2 _up 		= GetCurvatureValue(id,  0,  1) ; 
	float2 _right	= GetCurvatureValue(id,  1,  0) ;
	float2 _down 	= GetCurvatureValue(id,  0, -1) ;
	float2 _left_up 	= GetCurvatureValue(id,  -1,  1) ;
	float2 _right_up 	= GetCurvatureValue(id,   1,  1) ; 
	float2 _left_down	= GetCurvatureValue(id,  -1, -1) ;
	float2 _right_down 	= GetCurvatureValue(id,   1, -1) ;

	float _convexity_add = 0.0 ;
	float _concavitiy_add = 0.0 ;


	
	if(_this.y == 0)
	{

		if(_left.x >= _this.x )
			_convexity_add += (_left.x * 0.5) ;

		if(_up.x >= _this.x )
			_convexity_add += (_up.x * 0.5) ;

		if(_right.x >= _this.x )
			_convexity_add += (_right.x * 0.5) ;

		if(_down.x > _this.x )
			_convexity_add += (_down.x * 0.5) ;


		if(_left_up.x > _this.x )
			_convexity_add += (_left_up.x * 0.5) ;

		if(_right_up.x > _this.x )
			_convexity_add += (_right_up.x * 0.5) ;

		if(_left_down.x > _this.x )
			_convexity_add += (_left_down.x * 0.5) ;

		if(_right_down.x > _this.x )
			_convexity_add += (_right_down.x * 0.5) ;
		
	}
	
	if(_this.x == 0)
	{
		if(_left.y > _this.y )
			_concavitiy_add += (_left.y * 0.5) ;

		if(_up.y > _this.y )
			_concavitiy_add += (_up.y * 0.5) ;

		if(_right.y > _this.y )
			_concavitiy_add += (_right.y * 0.5) ;

		if(_down.y > _this.y )
			_concavitiy_add += (_down.y * 0.5) ;


		if(_left_up.y > _this.y )
			_concavitiy_add += (_left_up.y * 0.5) ;

		if(_right_up.y > _this.y )
			_concavitiy_add += (_right_up.y * 0.5) ;

		if(_left_down.y > _this.y )
			_concavitiy_add += (_left_down.y * 0.5) ;

		if(_right_down.y > _this.y )
			_concavitiy_add += (_right_down.y * 0.5) ;
	}



	convexity_concavitiy_flow_Maps_newCurvature[id.xy] += float4(_convexity_add, _concavitiy_add, 0.0, 0.0) ;
}



[numthreads(8,8,1)]
void CurvatureMap_Generate (uint3 id : SV_DispatchThreadID)
{
	float _convexity = saturate( convexity_concavitiy_flow_Maps_newCurvature[id.xy].x + convexity_concavitiy_flow_Maps[id.xy].x ) ;
	float _concavity = saturate( convexity_concavitiy_flow_Maps_newCurvature[id.xy].y + convexity_concavitiy_flow_Maps[id.xy].y ) ;

	convexity_concavitiy_flow_Maps[id.xy] = float4(_convexity , _concavity , convexity_concavitiy_flow_Maps[id.xy].zw) ;
}










[numthreads(8,8,1)]
void Generate_SplatMap (uint3 id : SV_DispatchThreadID)
{
	int _splatWeightArrayIndex = id.y * alphaMapResolution  +  id.x  ;

	float _weight = 0 ;	

	float _am = ((float)(alphaMapResolution -1)) ;
	float _hm = ((float)(heightmapResolution - 1)) ;

	float _normalized_x = ((float)id.x) / _am ;
	float _normalized_y = ((float)id.y) / _am ;

	uint _rounded_x = (uint)round(_normalized_x * _hm) ;
	uint _rounded_y = (uint)round(_normalized_y * _hm) ;
	
	uint3 _id = uint3(_rounded_x, _rounded_y, id.z) ;

	_weight	= CalcualteWeight(_id,   0 ,   0	, splatRuleBufferIndex , splat_Map_Total_Weight_Buffer[_splatWeightArrayIndex], _normalized_x, _normalized_y) ;

	splat_Map_Total_Weight_Buffer[_splatWeightArrayIndex] = _weight + splat_Map_Total_Weight_Buffer[_splatWeightArrayIndex] ;

	int _channel_index = (int)fmod(splatRuleBufferIndex , 4);

	if			(_channel_index == 0)
		{splatMapsArray[id.xy] = float4(_weight,    splatMapsArray[id.xy].yzw) ;}

	else if		(_channel_index == 1)
		{splatMapsArray[id.xy] = float4(splatMapsArray[id.xy].x,   _weight,   splatMapsArray[id.xy].zw) ;}

	else if		(_channel_index == 2)
		{splatMapsArray[id.xy] = float4(splatMapsArray[id.xy].xy,   _weight,   splatMapsArray[id.xy].w) ;}

	else if		(_channel_index == 3)
		{splatMapsArray[id.xy] = float4(splatMapsArray[id.xy].xyz,   _weight) ;}

	
}







[numthreads(8,8,1)]
void Normalize_SplatMap (uint3 id : SV_DispatchThreadID)
{
	int _splatWeightArrayIndex = id.y * alphaMapResolution  +  id.x  ;

	if(splat_Map_Total_Weight_Buffer[_splatWeightArrayIndex] > 1.0)
	{
		splatMapsArray[id.xy] /= splat_Map_Total_Weight_Buffer[_splatWeightArrayIndex] ;	
	}
}





[numthreads(8,8,1)]
void Generate_ColorMap (uint3 id : SV_DispatchThreadID)
{
	float position_X = (((float)id.x) / ((float)alphaMapResolution)) * terrainSize.x ;
	float position_Y = (((float)id.y) / ((float)alphaMapResolution)) * terrainSize.z ;
	float uvRepeat_X = position_X / uvSize ;
	float uvRepeat_Y = position_Y / uvSize ;
	uint uv_X = uint(frac(uvRepeat_X)) ;
	uint uv_Y = uint(frac(uvRepeat_Y)) ;
	uint2 index = uint2(uv_X, uv_Y);


	float4 color_diffuse = diffuseTexture[index] ;
	float4 color_normal = normalTexture[index] ;


	float weight = 0;

	int _channel_index = (int)fmod(splatRuleBufferIndex , 4);

	if			(_channel_index == 0)
		{weight = splatMapsArray[id.xy].x ;}

	else if		(_channel_index == 1)
		{weight = splatMapsArray[id.xy].y ;}

	else if		(_channel_index == 2)
		{weight = splatMapsArray[id.xy].z ;}

	else if		(_channel_index == 3)
		{weight = splatMapsArray[id.xy].w ;}
		

	

	colorMapDiffuse[id.xy] += color_diffuse * weight ;
	colorMapNormal[id.xy] += color_normal * weight ;

}







